// You should not need to edit this file directly.
// Use repositories.gradle and dependencies.gradle instead.

import groovy.json.JsonSlurper

plugins {
    id "java"
    id "com.github.johnrengelman.shadow" version "7.0.0"
}

configurations {
    internal
}

configurations.implementation.extendsFrom(configurations.internal)

java {
    sourceCompatibility = getVersionForMajor(javaSourceVersion)
    targetCompatibility = getVersionForMajor(javaTargetVersion)

    if (generateSourcesJar.toBoolean()) {
        withSourcesJar()
    }
    if (generateJavadocJar.toBoolean()) {
        withJavadocJar()
    }
}

// Configure shadowJar task
shadowJar {
    configurations = [project.configurations.internal]

    dependencies {
        include { dep -> project.configurations.internal.dependencies.contains(dep) }
    }

    project.configurations.internal.dependencies.each { dep ->
        if (dep.group && dep.name) {
            relocate "${dep.group}.${dep.name.replace('-', '.')}",
                    "net.kettlemc.${pluginName}.libs.${dep.group.replace('.', '_')}.${dep.name.replace('-', '_')}"
        }
    }
}

tasks.compileJava {
    options.encoding = "UTF-8"
}

tasks.javadoc {
    options.encoding = "UTF-8"
}

repositories {
    mavenCentral()
    maven {
        name = "kettlemc"
        url = "https://repo.kettlemc.net/repository/maven-public/"
    }
}

// Set group and version from properties
group = projectGroup
version = pluginVersion

// Load version mappings from api-versions.json

if (pluginApi) {

    println "Loading api mapping file..."
    def mappingFile = file("api-versions.json")
    if (!mappingFile.exists()) {
        throw new GradleException("Missing api-versions.json")
    }
    def versionMap = new JsonSlurper().parse(mappingFile)

    def artifactRepositories = versionMap[pluginApi]?.repositories
    if (!artifactRepositories) {
        throw new GradleException("Couldn't find repositories for the API '${pluginApi}'")
    }

    def artifactId = versionMap[pluginApi]?.artifact
    if (!artifactId) {
        throw new GradleException("Couldn't find artifact ID for the API '${pluginApi}'")
    }

    def artifactVersion = versionMap[pluginApi]?.versions?.get(minecraftVersion) ?: minecraftVersion
    if (!artifactVersion) {
        throw new GradleException("Couldn't find a version for the given API '${pluginApi} and Minecraft version: ${minecraftVersion}")
    }

    def apiAnnotationProcessor = versionMap[pluginApi]?.annotationProcessor
    if (apiAnnotationProcessor) {
        println "Using annotation processor '${apiAnnotationProcessor}' for API '${pluginApi}'"
        dependencies {
            annotationProcessor "${apiAnnotationProcessor}:${artifactVersion}".toString()
        }
    } else {
        println "No annotation processor found for API '${pluginApi}'"
    }

    // Add dynamic repositories for artifact
    for (repo in artifactRepositories) {
        var repoName = pluginApi.replace(":", "-").replace(".", "-")
        println "Adding repository '${repoName}' at '${repo}'"
        repositories {
            maven {
                name = repoName
                url = repo
            }
        }
    }

    // Add the artifact as a dependency
    println "Using artifact '${artifactId}:${artifactVersion}'"
    dependencies {
        compileOnly "${artifactId}:${artifactVersion}"
    }
}


dependencies {

    implementation fileTree(dir: "libs/implementation", include: "*.jar")
    internal fileTree(dir: "libs/internal", include: "*.jar")
    compileOnly "org.jetbrains:annotations:24.0.1"
}

// JASKL dependencies
if (jasklVersion && jasklImplementation) {
    if (jasklShadow.toBoolean()) {
        dependencies {
            internal "io.github.almighty-satan.jaskl:jaskl-${jasklImplementation}:${jasklVersion}"
        }
    } else {
        dependencies {
            implementation "io.github.almighty-satan.jaskl:jaskl-${jasklImplementation}:${jasklVersion}"
        }
    }
}

// SLAMS dependencies
if (slamsVersion && (slamsParser || slamsImplementation)) {
    if (slamsShadow.toBoolean()) {
        dependencies {
            if (slamsParser) internal "io.github.almighty-satan.slams:slams-parser-${slamsParser}:${slamsVersion}"
            if (slamsImplementation) internal "io.github.almighty-satan.slams:slams-${slamsImplementation}:${slamsVersion}"
        }
    } else {
        dependencies {
            if (slamsParser) implementation "io.github.almighty-satan.slams:slams-parser-${slamsParser}:${slamsVersion}"
            if (slamsImplementation) implementation "io.github.almighty-satan.slams:slams-${slamsImplementation}:${slamsVersion}"
        }
    }
}

// kLanguage dependencies
if (klanguageVersion) {
    dependencies {
        implementation "net.kettlemc.klanguage:klanguage-core:${klanguageVersion}"
        implementation "net.kettlemc.klanguage:klanguage-${klanguageImplementation}:${klanguageVersion}"
        implementation 'net.kyori:adventure-text-minimessage:4.14.0'
        implementation 'net.kyori:adventure-platform-bukkit:4.3.0'
    }
}

// kCommon dependencies
if (kcommonVersion) {
    dependencies {
        implementation "net.kettlemc:kcommon:${kcommonVersion}"
    }
}

// Apply external repository and dependency files if present
if (file("repositories.gradle").exists()) {
    apply from: "repositories.gradle"
}
if (file("dependencies.gradle").exists()) {
    apply from: "dependencies.gradle"
}

processResources {
    outputs.upToDateWhen { false }
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    from sourceSets.main.resources.srcDirs
    include "**/*.*"
    expand(
            "name": pluginName,
            "version": pluginVersion,
            "author": pluginAuthor,
            "description": pluginDescription,
            "website": pluginWebsite,
            "apiversion": pluginApiVersion,
            "main": pluginMain
    )
}

static def getVersionForMajor(String version) {
    return JavaVersion.values().find { it.majorVersion == version }
}
